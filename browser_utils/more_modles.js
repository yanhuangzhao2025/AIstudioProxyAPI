// ==UserScript==
// @name         Google AI Studio Model Injector (Multi-Model) - XHR+Fetch+ArrayStructure
// @namespace    http://tampermonkey.net/
// @version      1.6
// @description  Inject multiple custom models with themed emojis (Kingfall, Gemini, Goldmane, etc.) into the model list on Google AI Studio. Intercepts XHR/fetch, handles array-of-arrays JSON structure.
// @author       Generated by AI / HCPTangHY / Mozi
// @match        https://aistudio.google.com/*
// @icon         https://www.google.com/s2/favicons?sz=64&domain=aistudio.google.com
// @grant        none
// @run-at       document-start
// @license      MIT
// ==/UserScript==

(function() {
    'use strict';

     // ================== ÂÆö‰πâË¶ÅÊ≥®ÂÖ•ÁöÑÊ®°ÂûãÂàóË°® =====================
    // ‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì ÁâàÊú¨Âè∑ / EMOJIS Êõ¥Êñ∞ ‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì
    const SCRIPT_VERSION = "v1.6";
     // ‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì Ê®°ÂûãÂàóË°® EMOJIS Â∑≤Êõ¥Êñ∞ ‚Üì‚Üì‚Üì‚Üì‚Üì‚Üì
    const MODELS_TO_INJECT = [
       {
          name: 'models/kingfall-ab-test',
          displayName: `üëë Kingfall (Script ${SCRIPT_VERSION})`, // üëë King
          description: `Model injected by script ${SCRIPT_VERSION}`
       },
        {
          name: 'models/gemini-2.5-pro-preview-03-25',
          displayName: `‚ú® Gemini 2.5 Pro 03-25 (Script ${SCRIPT_VERSION})`, // ‚ú® Magic/AI
           description: `Model injected by script ${SCRIPT_VERSION}`
       },
        {
          name: 'models/goldmane-ab-test',
          displayName: `ü¶Å Goldmane (Script ${SCRIPT_VERSION})`, // ü¶Å Gold Mane
           description: `Model injected by script ${SCRIPT_VERSION}`
       },
        {
          name: 'models/claybrook-ab-test',
          displayName: `üíß Claybrook (Script ${SCRIPT_VERSION})`, // üíß Brook
           description: `Model injected by script ${SCRIPT_VERSION}`
       },
       {
           name: 'models/frostwind-ab-test',
          displayName: `‚ùÑÔ∏è Frostwind (Script ${SCRIPT_VERSION})`, // ‚ùÑÔ∏è Frost
           description: `Model injected by script ${SCRIPT_VERSION}`
       },
        {
           name: 'models/calmriver-ab-test',
           displayName: `üåä Calmriver (Script ${SCRIPT_VERSION})`, // üåä River
           description: `Model injected by script ${SCRIPT_VERSION}`
       },
        // ÂèØ‰ª•Âú®Ê≠§ÊåâÊ†ºÂºèÁªßÁª≠Ê∑ªÂä†Êõ¥Â§öÊ®°Âûã
    ];
      // ‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë Ê®°ÂûãÂàóË°® EMOJIS Â∑≤Êõ¥Êñ∞ ‚Üë‚Üë‚Üë‚Üë‚Üë‚Üë
     // ==========================================================

    const LOG_PREFIX = `[AI Studio Injector ${SCRIPT_VERSION}]:`;
    const ANTI_HIJACK_PREFIX = ")]}'\n";

    // --- ÂÖ≥ÈîÆÁ¥¢ÂºïÂÆö‰πâ (Âü∫‰∫éÊÇ®ÁöÑJSONÁªìÊûÑ) ---
     const NAME_IDX = 0;
     const DISPLAY_NAME_IDX = 3;
     const DESC_IDX = 4;
     const METHODS_IDX = 7;
    // ------------------------------------

    console.log(LOG_PREFIX, 'Script active. Patching Fetch and XHR...');

    function isTargetURL(url) {
       return url && typeof url === 'string' && url.includes('alkalimakersuite') && url.includes('/ListModels');
    }

    // ÈÄíÂΩíÊü•ÊâæÂåÖÂê´Ê®°ÂûãÊï∞ÁªÑÁöÑÊï∞ÁªÑ: ÂØªÊâæ `[ [model1_array], [model2_array], ... ]`
    function findModelListArray(obj) {
      if (!obj) return null;
       // Ê£ÄÊü• obj ÊòØÂê¶ÊòØÊàë‰ª¨ÂØªÊâæÁöÑÈÇ£‰∏™ÂåÖÂê´Â§ö‰∏™Ê®°ÂûãÊï∞ÁªÑÁöÑÊï∞ÁªÑ
      if (Array.isArray(obj) && obj.length > 0 && obj.every(
          item => Array.isArray(item) && typeof item[NAME_IDX] === 'string' && String(item[NAME_IDX]).startsWith('models/')
      )) {
        // console.log(LOG_PREFIX, "Target model list array FOUND."); // Reduce log noise
         return obj;
      }
       // ÈÄíÂΩíÊêúÁ¥¢
      if (typeof obj === 'object') {
          for (const key in obj) {
             if (Object.prototype.hasOwnProperty.call(obj, key)) {
                if(typeof obj[key] === 'object' && obj[key] !== null){ // check not null
                   const result = findModelListArray(obj[key]);
                   if (result) return result;
                }
             }
          }
      }
      return null;
    }


    // Ê†∏ÂøÉÔºöÂ§ÑÁêÜÂπ∂‰øÆÊîπ JSON Êï∞ÊçÆ - ‰ΩøÁî®Á¥¢ÂºïËÆøÈóÆÔºåÈÅçÂéÜÂ§ö‰∏™Ê®°Âûã
    function processJsonData(jsonData, url) {
         let modificationMade = false;
         const modelsArray = findModelListArray(jsonData); // [ [Ê®°Âûã1Êï∞ÁªÑ], [Ê®°Âûã2Êï∞ÁªÑ], ...]

         if(modelsArray && Array.isArray(modelsArray)){
           // console.log(LOG_PREFIX, 'Processing models array (length:', modelsArray.length, ") for URL:", url); // Reduce log noise

             // *** Âè™ÂØªÊâæ‰∏ÄÊ¨°Ê®°Êùø ***
             const templateModel = modelsArray.find(m => Array.isArray(m) && m[NAME_IDX] && String(m[NAME_IDX]).includes('flash') && Array.isArray(m[METHODS_IDX]) )
                                     || modelsArray.find(m => Array.isArray(m) && m[NAME_IDX] && String(m[NAME_IDX]).includes('pro') && Array.isArray(m[METHODS_IDX]) )
                                     || modelsArray.find(m => Array.isArray(m) && m[NAME_IDX] && Array.isArray(m[METHODS_IDX]) ); // ÊâæÁ¨¨‰∏Ä‰∏™ÊúâÊñπÊ≥ïÁöÑ

             const templateName = (templateModel && templateModel[NAME_IDX]) ? templateModel[NAME_IDX] : 'unknown';
              if(templateModel){
                 // console.log(LOG_PREFIX, `Using template: ${templateName}`); // Reduce log noise
              } else {
                   console.warn(LOG_PREFIX, 'Could not find a suitable template model array. Cannot inject new models, but can update existing ones.');
              }

             // *** ÈÅçÂéÜÊâÄÊúâÈúÄË¶ÅÊ≥®ÂÖ•ÁöÑÊ®°Âûã ***
             // ‰ΩøÁî® reverse, ‰ΩøÂæó MODELS_TO_INJECT Êï∞ÁªÑ‰∏≠ÁöÑÈ°∫Â∫èÂíåÊúÄÁªàÊòæÁ§∫Âú®È°∂ÈÉ®ÁöÑÈ°∫Â∫è‰∏ÄËá¥
             [...MODELS_TO_INJECT].reverse().forEach(modelToInject => {
                  const modelExists = modelsArray.some(model => Array.isArray(model) && model[NAME_IDX] === modelToInject.name);

                   if (!modelExists) {
                        if(!templateModel) {
                           console.warn(LOG_PREFIX, `Cannot inject ${modelToInject.name}: No template found.`);
                           return; // Skip this model if no template
                        }
                         // ÔºÅÔºÅÔºÅÂÖ≥ÈîÆ: ÂøÖÈ°ªÊ∑±Êã∑Ë¥ùÊï∞ÁªÑÔºÅÔºÅÔºÅ
                         const newModel = JSON.parse(JSON.stringify(templateModel)); // Deep Clone from template

                         // ÔºÅÔºÅÔºÅÂÖ≥ÈîÆ: ‰ΩøÁî®Á¥¢Âºï‰øÆÊîπ ÔºÅÔºÅÔºÅ
                         newModel[NAME_IDX] = modelToInject.name;
                         newModel[DISPLAY_NAME_IDX] = modelToInject.displayName;
                         newModel[DESC_IDX] = `${modelToInject.description} (Structure based on ${templateName})`;
                          if(!Array.isArray(newModel[METHODS_IDX])){
                             newModel[METHODS_IDX] = ["generateContent", "countTokens","createCachedContent","batchGenerateContent"];
                          }
                         modelsArray.unshift(newModel); // Ê∑ªÂä†Âà∞ÂºÄÂ§¥
                         modificationMade = true;
                         console.log(LOG_PREFIX, `Successfully INJECTED: ${modelToInject.displayName}`);

                   } else {
                      // console.log(LOG_PREFIX, `Model ALREADY EXISTS: ${modelToInject.name}. Checking displayName.`); // Reduce log noise
                       const existing = modelsArray.find(model => Array.isArray(model) && model[NAME_IDX] === modelToInject.name);
                        // Â¶ÇÊûúÂ≠òÂú®Ôºå‰ΩÜÂêçÂ≠ó‰∏çÊòØËÑöÊú¨ËÆæÂÆöÁöÑÂêçÂ≠óÔºå‰∏î‰∏çÂåÖÂê´ÂΩìÂâçÁâàÊú¨Âè∑ÔºåÂàôÊõ¥Êñ∞ÂêçÂ≠ó
                        // Â¶ÇÊûúÊ®°ÂûãÂ∑≤Â≠òÂú®Ôºå‰∏îÂêçÂ≠óÂ∞±ÊòØÊàë‰ª¨ËÆæÂÆöÁöÑÔºà‰æãÂ¶ÇÂà∑Êñ∞È°µÈù¢ÔºâÔºåÊàë‰ª¨‰πüÊõ¥Êñ∞‰∏Ä‰∏ãÔºåÁ°Æ‰øùemojiÂíåÁâàÊú¨Âè∑ÊòØÊúÄÊñ∞ÁöÑ
                         if(existing && existing[DISPLAY_NAME_IDX] !== modelToInject.displayName) {
                            // Ê£ÄÊü•ÊòØÂê¶Âè™ÊòØÁâàÊú¨Âè∑Êàñemoji‰∏çÂêå
                            const baseExistingName = String(existing[DISPLAY_NAME_IDX]).replace(/ \(Script v\d+\.\d+(-beta\d*)?\)/, '').replace(/^[üëë‚ú®ü¶Åüíß‚ùÑÔ∏èüåä]\s*/,'').trim();
                            const baseInjectName = modelToInject.displayName.replace(/ \(Script v\d+\.\d+(-beta\d*)?\)/, '').replace(/^[üëë‚ú®ü¶Åüíß‚ùÑÔ∏èüåä]\s*/,'').trim();

                             if (baseExistingName === baseInjectName) {
                                  // Âü∫Á°ÄÂêçÂ≠óÁõ∏ÂêåÔºåÂè™Êõ¥Êñ∞emojiÂíåÁâàÊú¨Âè∑
                                  existing[DISPLAY_NAME_IDX] = modelToInject.displayName;
                                  console.log(LOG_PREFIX, `Updated Emoji/Version for ${modelToInject.displayName}.`);
                             } else {
                                 // Âü∫Á°ÄÂêçÂ≠ó‰∏çÂêåÔºåËØ¥ÊòéÊòØÂÆòÊñπËá™Â∏¶ÁöÑÊàñÂÖ∂‰ªñÊù•Ê∫êÔºåÂä†‰∏ä (Orig)
                                  existing[DISPLAY_NAME_IDX] = modelToInject.displayName + " (Orig)";
                                  console.log(LOG_PREFIX, `Updated displayName for existing official ${modelToInject.name} to (Orig).`);
                             }
                             modificationMade = true;
                        }
                   }
             }); // End forEach

       } else {
            console.warn(LOG_PREFIX, 'URL matched, but no valid model list array structure found in JSON for:', url);
       }
       return { data: jsonData, modified: modificationMade };
    }

     // Áªü‰∏ÄÂ§ÑÁêÜÂìçÂ∫î‰ΩìÊñáÊú¨ (Ëß£Êûê, Â§ÑÁêÜ, Â∫èÂàóÂåñ)
    function modifyResponseBody(originalText, url) {
         if (!originalText || typeof originalText !== 'string') return originalText; // Add type check
          try {
             let textBody = originalText;
             let hasPrefix = false;
             if (textBody.startsWith(ANTI_HIJACK_PREFIX)) {
                 textBody = textBody.substring(ANTI_HIJACK_PREFIX.length);
                 hasPrefix = true;
             }
             if(!textBody.trim()) return originalText;
             const jsonData = JSON.parse(textBody);
             const result = processJsonData(jsonData, url);
             if (result.modified) {
                 let newBody = JSON.stringify(result.data);
                 if(hasPrefix){
                    newBody = ANTI_HIJACK_PREFIX + newBody;
                 }
                // console.log(LOG_PREFIX, "Returning MODIFIED response body."); // Reduce log noise
                 return newBody;
             }
         } catch (error) {
             console.error(LOG_PREFIX, 'Error processing response body for:', url, error, "\nOriginal Text snippet:", String(originalText).substring(0, 300) + "...");
         }
          // console.log(LOG_PREFIX, "Returning ORIGINAL response body (no modification or error)."); // Reduce log noise
         return originalText;
     }

    //==================================
    // Êã¶Êà™ Fetch (‰øùÁïô)
    //==================================
    const originalFetch = window.fetch;
    window.fetch = async function(...args) {
       const resource = args[0];
       const url = (resource instanceof Request) ? resource.url : String(resource);
       const response = await originalFetch.apply(this, args);
        if (isTargetURL(url) && response.ok) {
           console.log(LOG_PREFIX, '[Fetch] Intercepting:', url);
            try {
                 const cloneResponse = response.clone();
                 const originalText = await cloneResponse.text();
                 const newBody = modifyResponseBody(originalText, url);
                  if(newBody !== originalText){
                    return new Response(newBody, { status: response.status, statusText: response.statusText, headers: response.headers });
                 }
            } catch(e) { console.error(LOG_PREFIX, '[Fetch] Error:', e); }
       }
       return response;
    };
     console.log(LOG_PREFIX, 'Fetch patch applied.');

    //==================================
    // Êã¶Êà™ XMLHttpRequest (XHR)
    //==================================
     const xhrProto = XMLHttpRequest.prototype;
     const originalOpen = xhrProto.open;
     const originalResponseTextDescriptor = Object.getOwnPropertyDescriptor(xhrProto, 'responseText');
     const originalResponseDescriptor = Object.getOwnPropertyDescriptor(xhrProto, 'response');
     let interceptionCount = 0;

     xhrProto.open = function(method, url) {
         this._interceptorUrl = url;
         this._isTargetXHR = isTargetURL(url);
          if(this._isTargetXHR){
              interceptionCount++;
               console.log(LOG_PREFIX, `[XHR] Open detected (${interceptionCount}) for:`, url);
          }
         return originalOpen.apply(this, arguments);
     };

      const handleXHRResponse = (xhr, originalValue, type = 'text') => {
           if (xhr._isTargetXHR && xhr.readyState === 4 && xhr.status === 200) {
                const cacheKey = '_modifiedResponseCache_' + type;
                 if(xhr[cacheKey] === undefined){
                   // console.log(LOG_PREFIX, `[XHR] Processing response[${type}] for:`, xhr._interceptorUrl); // Reduce log noise
                     const originalText = (type === 'text' || typeof originalValue !== 'object' || originalValue === null) ? String(originalValue || '') : JSON.stringify(originalValue) ;
                      // Cache the result of modifyResponseBody
                      xhr[cacheKey] = modifyResponseBody(originalText, xhr._interceptorUrl);
                 }
                 // Use the cached result
                 const cachedResponse = xhr[cacheKey];
                try{
                   // Â¶ÇÊûúÊòØÂØπË±°Á±ªÂûã,‰∏îÁºìÂ≠òÁöÑÊòØÂ≠óÁ¨¶‰∏≤ÔºåËøîÂõûÊó∂ÈúÄË¶ÅÂèçÂ∫èÂàóÂåñ
                   if (type === 'json' && typeof cachedResponse === 'string') {
                      // Ensure the string is not empty before parsing
                      const textToParse = cachedResponse.replace(ANTI_HIJACK_PREFIX,'');
                       if (textToParse) {
                         return JSON.parse(textToParse);
                       }
                       return null; // or originalValue if parsing empty string is an issue
                   }
                 } catch(e){
                     console.error(LOG_PREFIX, `[XHR] Error parsing cached JSON for type 'json': `, e, `Cache content: ${String(cachedResponse).substring(0,100)}...`);
                    return originalValue; // fallback
                 }
                 return cachedResponse; // text type or already object or empty string
           }
            return originalValue;
      };


      if(originalResponseTextDescriptor && originalResponseTextDescriptor.get) {
          Object.defineProperty(xhrProto, 'responseText', {
              get: function() {
                   const originalText = originalResponseTextDescriptor.get.call(this);
                    // Only handle if responseType is text or default ""
                   if (this.responseType && this.responseType !== 'text' && this.responseType !== "") return originalText;
                   return handleXHRResponse(this, originalText, 'text');
              }, configurable: true
          });
           console.log(LOG_PREFIX, 'XHR responseText patch applied.');
      } else { console.error(LOG_PREFIX, 'XHR: Failed to get original responseText descriptor!'); }

       if(originalResponseDescriptor && originalResponseDescriptor.get) {
            Object.defineProperty(xhrProto, 'response', {
               get: function() {
                   const originalResponse = originalResponseDescriptor.get.call(this);
                    if (this.responseType === 'json') {
                         return handleXHRResponse(this, originalResponse, 'json');
                    }
                    // When responseType is "" or "text", originalResponse is the text itself
                     if (!this.responseType || this.responseType === 'text' || this.responseType === "") {
                          return handleXHRResponse(this, originalResponse, 'text');
                     }
                   return originalResponse; // other types like blob, arraybuffer
               }, configurable: true
           });
            console.log(LOG_PREFIX, 'XHR response patch applied.');
       } else {
            console.error(LOG_PREFIX, 'XHR: Failed to get original response descriptor!');
       }
      console.log(LOG_PREFIX, 'XHR open patch applied.');

})();